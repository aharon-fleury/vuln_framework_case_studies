---
title: "Process species trait spreadsheets"
author: "*Compiled on `r date()` by `r Sys.info()['user']`*"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_depth: 3
    toc_float: yes
    number_sections: true
    theme: cerulean
    highlight: haddock
    includes: 
      in_header: '~/github/src/templates/ohara_hdr.html'
  pdf_document:
    toc: true
---

``` {r setup, echo = TRUE, message = FALSE, warning = FALSE}

knitr::opts_chunk$set(fig.width = 6, fig.height = 4, fig.path = 'figs/',
                      echo = TRUE, message = FALSE, warning = FALSE)

source('https://raw.githubusercontent.com/oharac/src/master/R/common.R')

```

# Summary

Read in Excel spreadsheets of taxonomic traits filled in by taxon experts.  Process into a long/tidy format with checks on validity of category values.  Identify categories that were assigned non-valid values.

# Data

`_raw_data/all_taxa_trait_data.xlsx' is the raw spreadsheet prepared by Nathalie Butt from the various submissions of the taxa-group experts.  Basic format:

Columns `category`, `sub-category`, and `category units` are standard.  Additional columns correspond to species or species groups, with perhaps additional idiosyncratic columns populated with totals, notes, comments, etc.

# Methods

Set up path and sheetnames

```{r}
raw_file <- here('_raw_data/all_taxa_trait_data.xlsx')

sheetnames <- readxl::excel_sheets(raw_file)
sheetnames <- sheetnames[sheetnames != 'habitat_list'] ### drop extraneous sheet
```

Create a category/subcategory lookup with all valid entries?  Too much inconsistency from category to category! try to get one working, but FFS.  Ask Nat to clean this up.

```{r}
catvals_df_raw <- readxl::read_excel(raw_file, sheet = sheetnames[1]) %>%
  select(1:3) %>%
  janitor::clean_names() %>%
  filter(!(is.na(category) & is.na(sub_category))) %>%
  fill(category, .direction = 'down')

catvals_df_prehabs <- catvals_df_raw %>%
  ### drop internal commas in numbers:
  mutate(cat_vals = str_replace_all(category_units, '(?<=[0-9]),(?=[0-9])', '')) %>%
  ### inconsistent separators, ugh: temp replace necessary slashes?
  mutate(cat_vals = tolower(cat_vals),
         cat_vals = str_replace_all(cat_vals, 'live birth/ egg care', 'live birthX egg care')) %>%
  ### missing separators, ugh: turn > into ;> so it separates properly (extraneous dropped later)
  mutate(cat_vals = str_replace_all(cat_vals, '>', ';>')) %>%
  ### fix typos:
  mutate(cat_vals = str_replace_all(cat_vals, 'dioeciuos', 'dioecious')) %>%
  ### split values and unnest
  mutate(cat_vals = str_split(cat_vals, pattern = ',|;|/')) %>%
  unnest(cat_vals) %>%
  ### trim whitespace, replace the temporary slash fixes
  mutate(cat_vals = str_trim(cat_vals),
         cat_vals = str_replace(cat_vals, 'X', '/')) %>%
           ### undo the temp slash fix
  filter(!is.na(cat_vals)) %>%
  filter(cat_vals != '') %>%
  select(category, sub_category, cat_vals)

### Read in the first column of habitats from the list.  Paste together with
### semicolon separator.  Set to lower case.
habs <- readxl::read_excel(here('_raw_data/hab_list.xlsx')) %>%
  janitor::clean_names() %>%
  .$habitat_types %>%
  tolower() %>%
  paste(collapse = ';')
    
### Separate out habitat rows, attach valid habitats, bind back to original.
catvals_hab <- catvals_df_prehabs %>%
  filter(str_detect(cat_vals, 'habitats')) %>%
  mutate(cat_vals = habs,
         cat_vals = str_split(habs, pattern = ';')) %>%
  unnest(cat_vals)
  

catvals_df_valid <- catvals_df_prehabs %>%
  filter(!str_detect(cat_vals, 'habitats')) %>%
  bind_rows(catvals_hab)

write_csv(catvals_df_valid, 'category_vals_valid.csv')
```

Read in Excel sheets one at a time, convert to long format, bind into a single dataframe with minimal processing.

First, check headers to make sure there's not taxonomic information in multiple rows.  The first row of each sheet should be blank, as most sheets have a space before the first category ("Movement").  Even without this space, "Movement" should not have any values of its own, so still blank.

```{r}
check_headers <- function(f, s) {
  df <- readxl::read_excel(path = f, sheet = s, n_max = 1) %>%
    gather(hdg, val, -c(1:3)) %>%
    select(hdg, val) %>%
    mutate(sheet = s)
  return(df)
}

hdr_check <- lapply(sheetnames, FUN = function(s) check_headers(raw_file, s)) %>%
  bind_rows() %>%
  filter(!is.na(val))

probs <- hdr_check$sheet %>% unique()
```

The following sheets seem to have additional information with headers: `r probs`.

* Cephalopods have order info in first line (which becomes header) then species info in second line (which should be captured as the taxonomic group).
* Reef fishes have a species count in the first line (which becomes header) then genus/species in the second line (which should be captured as the taxonomic group).
* Corals have genus in top line, and then spp count in second line.  Not a problem; this will be dropped.
* Echinoderms have species names in top row (which becomes header, OK) then some limited info on order in second row (which will be dropped).

``` {r}
process_sheet <- function(f, s) {
  ### f <- raw_file; s <- sheetnames[1]
  df_raw <- readxl::read_excel(path = f, sheet = s)
  
  if(s %in% c('cephalopods', 'reef_other_fish')) {
    ### problematic spp sheets - taxonomic info in second line of csv
    spp_names <- df_raw[1, ]
    spp_names[1:3] <- c('category', 'sub_category', 'category units')
    df_raw <- df_raw %>%
      setNames(spp_names)
  }
    
  df <- df_raw %>%
    gather(spp_gp, trait_val, -c(1:3)) %>%
    janitor::clean_names() %>%
    select(-category_units)
  
  df_cleaned <- df %>%
    filter(!(is.na(category) & is.na(sub_category))) %>%
      ### drops rows with neither category nor sub-category - these
      ### should be spacer rows
    fill(category, .direction = 'down') %>%
    filter(!is.na(trait_val)) %>%
    mutate(sheet = s)
  
  return(df_cleaned)
}

raw_data_df <- lapply(sheetnames, FUN = function(s) process_sheet(raw_file, s)) %>%
  bind_rows()
```

Check raw data against valid category values.

* Set all values to lower case to avoid case sensitivity.
* replace "n/a" with "na"
* Ditch numeric commas.
* Split trait values on semicolons to separate multiple cell values; then unnest and str_trim.

```{r}
spp_data_clean <- raw_data_df %>%
  mutate(trait_val = str_replace_all(trait_val, '(?<=[0-9]),(?=[0-9])', ''),
         trait_val = tolower(trait_val)) %>%
  ### split and unnest:
  mutate(trait_val = str_split(trait_val, ';')) %>%
  unnest(trait_val) %>%
  ### trim whitespace, fix a few idiosyncratic fuckups
  mutate(trait_val = str_trim(trait_val)) %>%
  mutate(trait_val = ifelse(trait_val == 'n/a', 'na', trait_val)) %>%
  filter(trait_val != '')

spp_validcheck <- spp_data_clean %>%
  left_join(catvals_df_valid %>% mutate(valid = TRUE), 
            by = c('category', 'sub_category', 'trait_val' = 'cat_vals')) %>%
  filter(!is.na(spp_gp))

spp_invalid <- spp_validcheck %>%
  filter(is.na(valid)) %>%
  filter(trait_val != 'na') %>%
  select(-valid)
write_csv(spp_invalid, 'invalid_spp_category_values.csv')

spp_na_val <- spp_validcheck %>%
  filter(is.na(valid)) %>%
  filter(trait_val == 'na') %>%
  select(-valid)
write_csv(spp_na_val, 'na_spp_category_values.csv')

spp_valid <- spp_validcheck %>%
  filter(valid)

spp_valid$spp_gp %>% n_distinct()
```

