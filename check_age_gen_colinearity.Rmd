---
title: 'check correlation of traits'
author: "Casey O'Hara"
date: '9/2/2020'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(MASS) ### don't mask select
library(tidyverse)
```
## Load the data and clean up the values; then convert to ordered factors.

```{r}
spp_reprod <- read_csv('_data/spp_traits_valid.csv') %>%
  filter(trait %in% c('age_to_1st_reproduction_generation_time', 'max_age', 'lifetime_reproductive_opportunities')) %>%
  select(-trait_val_clean) %>%
  spread(trait, trait_value) %>%
  rename(gen_time = age_to_1st_reproduction_generation_time, opps = lifetime_reproductive_opportunities) %>%
  mutate(gen_time = str_replace_all(gen_time, ' ', ''),
         gen_time = str_replace_all(gen_time, 'rs?', ''),
         max_age  = str_replace_all(max_age, ' ', ''),
         max_age  = str_replace_all(max_age, 'onths?|rs?', ''),
         opps     = str_replace_all(opps, ' ', ''))

### categorize by levels for each variable
# spp_reprod$gen_time %>% unique()
# '<1y'     NA         '1-5y'   '5-10y'  '10-20y' '>20y' 
# spp_reprod$max_age %>% unique()
# [1] "3m-1y"                NA                     "20-100y"              "1-5y"                
# [5] "5-10y"                "10-20y"               ">100y"                "<3m"                 
# [9] "5-10y;10-20y,20-100y"
# spp_reprod$opps %>% unique()
#  '1'      NA       '26-50'  '51-100' '2-10'   '11-25'  '100+' 

spp_reprod_fct <- spp_reprod %>%
  mutate(gen_time = factor(gen_time, levels = c('<1y', '1-5y', '5-10y', '10-20y', '>20y')),
         max_age  = factor(max_age, levels = c('3m-1y', '1-5y', '5-10y', '10-20y', '20-100y', '>100y')),
         opps     = factor(opps, levels = c('1',  '2-10', '11-25', '26-50', '51-100', '100+')))

summary(spp_reprod_fct)
```

## check gen time against reproductive opportunities 

For regressions, I am performing an ordinal logistic regression using `polr()` from the `MASS` package.  See [this page](https://stats.idre.ucla.edu/r/dae/ordinal-logistic-regression/) for details

I wouldn't expect strong correlation here between time to first reproduction and the number of lifetime opportunities.

``` {r}
### drop NAs - otherwise they show up in plot.
df1 <- spp_reprod_fct %>%
  filter(!is.na(opps) & !is.na(gen_time))

ggplot(df1, aes(x = gen_time, y = opps)) +
  geom_jitter(width = .2, height = .2)
```

The plot doesn't give us much help.  Tons of fast-maturing species are one-and-done.

``` {r}
lr1 <- polr(opps ~ gen_time, data = df1, Hess = TRUE)

summary(lr1)
```

Notation and concepts from [this page](https://stats.idre.ucla.edu/other/mult-pkg/faq/ologit/) and [this one](https://towardsdatascience.com/implementing-and-interpreting-ordinal-logistic-regression-1ee699274cf5):

Let $Y$ be an ordinal outcome with $J$ categories.  Then $P(Y\leq J)$ is cumulative probability of $Y$ less than or equal to a specific category $j = 1, ..., J-1$.  Note $P(Y \leq J) = 1$.  

Odds of being less than or equal to a particular category can be defined as
$$\frac{P(Y \leq j)}{P(Y>j)}$$
for $j = 1, ..., J-1$ since $P(Y>J) = 0$ and can't divide by zero.  Log odds or *logit* is
$$log \left(\frac{P(Y \leq j)}{P(Y>j)}\right) = logit(P(Y\leq j))$$
Coefficients are interpreted as:
$$logit(P(Y \leq j)) = \beta_{j0} + \beta_{j1}x_1 + ... + \beta_{jp}x_p$$
which under the *parallel lines assumption* the intercepts are different for each category but slopes are constant across categories, so this simplifies to:
$$logit(P(Y \leq j)) = \beta_{j0} - [\beta_{1}x_1 + ... + \beta_{p}x_p]$$
and for a single predictor,
$$logit(P(Y \leq j)) = \beta_{j0} - \beta_{1}x_1$$
Here, $j = 1$ means 1 lifetime reproductive opportunity; $j = 2$ means 2-10 opportunities, etc. up to $j = 6$ for 100+ opportunities. Subscript 1 is coefficient for generation time, which here is just considered an unordered categorical variable with levels $1-5yrs, 5-10yrs, 10-20yrs, >20yrs$; $<1yr$ is absorbed by the intercept.

The |t-values| are all larger than 2, so are well past p < .05.  So for $x_1 = 5-10yrs$, probability of $j=1$ (1 lifetime opportunity) or less:
$$logit(P(Y \leq 1)) = 3.6031 - 1.425 = 2.1781$$
$$\Rightarrow P(Y \leq 1) = exp(2.1781)/(1 + exp(2.1781)) = 0.898$$

For $Y = 2$ (corresponding to 2-10 $$logit(P(Y \leq 2)) = 5.0759 - 1.425 = 3.6509$$
$$\Rightarrow P(Y \leq 2) = exp(3.6509)/(1 + exp(3.6509)) = 0.974$$
$$\Rightarrow P(Y = 2) = P(Y \leq 2) - P(Y \leq 1) = 0.974 - 0.898 = 0.076$$
so basically as your generation time increases, you have a small chance of bumping up in opportunities (since these seem to be dominated by one-shot spp)

Let's apply that to max age against generation time which should be more decisive.

## check max age against gen time

I would expect a decent correlation between age to first reproduction and maximum age - at very least, the first is bounded on the top end by the second; and many long-lived creatures are known to take a long time to mature.

``` {r}

df2 <- spp_reprod_fct %>%
         filter(!is.na(gen_time) & !is.na(max_age))
ggplot(df2, aes(x = gen_time, y = max_age)) +
  geom_jitter(width = .2, height = .2)
```

That looks like more of a regular pattern.

``` {r}
lr2 <- polr(max_age ~ gen_time, data = df2, Hess = TRUE)

summary(lr2)
```

These t values are all pretty small though.  Not very convincing.

## check max age against reproductive opportunities 

This would probably have a decent correlation, since living longer allows more seasons in which reproduction can occur.

``` {r}
df3 <- spp_reprod_fct %>%
         filter(!is.na(opps) & !is.na(max_age))
ggplot(df3, aes(x = opps, y = max_age)) +
  geom_jitter(width = .2, height = .2)
```

There seems to be a bit of a pattern here...

``` {r}
lr3 <- polr(max_age ~ opps, data = df3, Hess = TRUE)
summary(lr3)
```

Check out those t-values!  only the coefficient for 100+ is not significant.

Let's figure out how to plot this on a heat map maybe.  

```{r}
coeff3 <- lr3$coefficients
intcp3 <- lr3$zeta
x_lvls <- df3$opps %>% levels()
y_lvls <- df3$max_age %>% levels()

prob_df <- crossing(x = x_lvls, y = y_lvls) %>%
  mutate(x = factor(x, levels = x_lvls),
         y = factor(y, levels = y_lvls)) %>%
  arrange(x, y) %>%
  group_by(x) %>%
  mutate(x1 = paste0('opps', x),
         y1 = paste0('max_age', y),
         y2 = paste0(y, '|', lead(y))) %>%
  mutate(intcp = intcp3[y2],
         coeff = coeff3[x1],
         coeff = ifelse(is.na(coeff), 0, coeff),
         logit_y_lt_j = intcp - coeff,
         p_y_lt_j = exp(logit_y_lt_j) / (1 + exp(logit_y_lt_j)),
         p_y_lt_j = ifelse(is.na(p_y_lt_j), 1, p_y_lt_j),
         p_y_eq_j = p_y_lt_j - lag(p_y_lt_j, default = 0))

ggplot(prob_df %>% filter(x != '100+'), aes(x = x, y = y)) +
  geom_tile(aes(fill = p_y_eq_j)) +
  scale_fill_viridis_c() +
  labs(x = '# of lifetime reproductive opportunities',
       y = 'max age')
```

## check max age against reproductive opportunities and gen time

``` {r}
lr4 <- polr(max_age ~ opps + gen_time, data = spp_reprod_fct, Hess = TRUE)
summary(lr4)
```

Those t-values don't look great.

<!-- ## Maybe max age used to gapfill gen time? -->

``` {r, eval = FALSE, echo = FALSE}

na_gen <- sum(is.na(spp_reprod_fct$gen_time)) / nrow(spp_reprod_fct)
na_age <- sum(is.na(spp_reprod_fct$max_age)) / nrow(spp_reprod_fct)

na_gen_gapfill <- sum(is.na(spp_reprod_fct$gen_time) & !is.na(spp_reprod_fct$max_age)) / sum(is.na(spp_reprod_fct$gen_time)) 


# `r round(na_gen * 100)`% of species groups (n = `r sum(is.na(spp_reprod_fct$gen_time))`) have missing values for generation time.  `r round(na_gen * 100)`% of species groups (n = `r sum(is.na(spp_reprod_fct$max_age))`) have missing values for max age.  Using max age to gapfill generation time could fill `r round(na_gen_gapfill * 100)`% (n = `r sum(is.na(spp_reprod_fct$gen_time) & !is.na(spp_reprod_fct$max_age))`) of those missing values.

```

## Are the dropped variables biased by taxon?

i.e. perhaps certain experts chose to code one variable to the exclusion of another.

``` {r}
tmp_df <- spp_reprod %>% 
  group_by(sheet) %>% 
  summarize(pct_na_max_age = sum(is.na(max_age)) / n(),
            pct_na_opps = sum(is.na(opps)) / n(),
            pct_na_gen_time = sum(is.na(gen_time)) / n())

knitr::kable(tmp_df)
```